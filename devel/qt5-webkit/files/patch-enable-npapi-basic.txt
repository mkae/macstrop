diff --git a/Source/WebKit/PlatformQt.cmake b/Source/WebKit/PlatformQt.cmake
index da199aeafbf097e7afbc59bd60f9143225858e3d..678a5e121b848a86f6880cc5835ca17dd0e45dc7 100644
--- a/Source/WebKit/PlatformQt.cmake
+++ b/Source/WebKit/PlatformQt.cmake
@@ -309,6 +321,13 @@ if (ENABLE_NETSCAPE_PLUGIN_API)
             qt/Plugins/PluginViewQt.cpp
         )
     endif ()
+    if (APPLE)
+        list(APPEND WebKit_SOURCES
+            mac/Plugins/PluginPackageMac.cpp
+            mac/Plugins/PluginViewMac.mm
+            mac/Plugins/WebCoreNSStringExtras.mm
+        )
+    endif ()
 
     if (WIN32)
         list(APPEND WebKit_INCLUDE_DIRECTORIES
diff --git a/Source/WebKit/mac/Plugins/PluginPackageMac.cpp b/Source/WebKit/mac/Plugins/PluginPackageMac.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..2e7739aaa14f82a0c98b5da77d83f743c19bcfd5
--- /dev/null
+++ b/Source/WebKit/mac/Plugins/PluginPackageMac.cpp
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2006, 2007 Apple Inc.  All rights reserved.
+ * Copyright (C) 2008 Collabora Ltd. All rights reserved.
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "PluginPackage.h"
+
+#include <wtf/RetainPtr.h>
+#include "MIMETypeRegistry.h"
+#include "npruntime_impl.h"
+#include "PluginDatabase.h"
+#include "PluginDebug.h"
+#include "WebCoreNSStringExtras.h"
+#include <wtf/text/CString.h>
+
+#include <CoreFoundation/CoreFoundation.h>
+
+#define PluginNameOrDescriptionStringNumber     126
+#define MIMEDescriptionStringNumber             127
+#define MIMEListStringStringNumber              128
+
+namespace WebCore {
+
+void PluginPackage::determineQuirks(const String& mimeType)
+{
+    if (MIMETypeRegistry::isJavaAppletMIMEType(mimeType)) {
+        // Because a single process cannot create multiple VMs, and we cannot reliably unload a
+        // Java VM, we cannot unload the Java Plugin, or we'll lose reference to our only VM
+        m_quirks.add(PluginQuirkDontUnloadPlugin);
+
+        // Setting the window region to an empty region causes bad scrolling repaint problems
+        // with the Java plug-in.
+        m_quirks.add(PluginQuirkDontClipToZeroRectWhenScrolling);
+    }
+
+    if (mimeType == "application/x-shockwave-flash") {
+        m_quirks.add(PluginQuirkWantsChromeUserAgent);
+        m_quirks.add(PluginQuirkThrottleInvalidate);
+        m_quirks.add(PluginQuirkThrottleWMUserPlusOneMessages);
+        m_quirks.add(PluginQuirkFlashURLNotifyBug);
+    }
+
+}
+
+typedef void (*BP_CreatePluginMIMETypesPreferencesFuncPtr)(void);
+
+static WTF::RetainPtr<CFDictionaryRef> readPListFile(CFStringRef fileName, bool createFile, CFBundleRef bundle)
+{
+    if (createFile) {
+        BP_CreatePluginMIMETypesPreferencesFuncPtr funcPtr =
+            (BP_CreatePluginMIMETypesPreferencesFuncPtr)CFBundleGetFunctionPointerForName(bundle, CFSTR("BP_CreatePluginMIMETypesPreferences"));
+        if (funcPtr)
+            funcPtr();
+    }
+
+    WTF::RetainPtr<CFDictionaryRef> map;
+    WTF::RetainPtr<CFURLRef> url =
+        CFURLCreateWithFileSystemPath(kCFAllocatorDefault, fileName, kCFURLPOSIXPathStyle, false);
+
+    CFDataRef resource = 0;
+    SInt32 code;
+    if (!CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, url.get(), &resource, 0, 0, &code))
+        return map;
+
+    WTF::RetainPtr<CFPropertyListRef> propertyList =
+            CFPropertyListCreateFromXMLData(kCFAllocatorDefault, resource, kCFPropertyListImmutable, 0);
+
+    CFRelease(resource);
+
+    if (!propertyList)
+        return map;
+
+    if (CFGetTypeID(propertyList.get()) != CFDictionaryGetTypeID())
+        return map;
+
+    map = static_cast<CFDictionaryRef>(static_cast<CFPropertyListRef>(propertyList.get()));
+    return map;
+}
+
+static Vector<String> stringListFromResourceId(SInt16 id)
+{
+    Vector<String> list;
+
+    Handle handle = Get1Resource('STR#', id);
+    if (!handle)
+        return list;
+
+    CFStringEncoding encoding = stringEncodingForResource(handle);
+
+    unsigned char* p = (unsigned char*)*handle;
+    if (!p)
+        return list;
+
+    SInt16 count = *(SInt16*)p;
+    p += sizeof(SInt16);
+
+    for (SInt16 i = 0; i < count; ++i) {
+        unsigned char length = *p;
+        WTF::RetainPtr<CFStringRef> str = adoptCF(CFStringCreateWithPascalString(0, p, encoding));
+        list.append(str.get());
+        p += 1 + length;
+    }
+
+    return list;
+}
+
+bool PluginPackage::fetchInfo()
+{
+    if (!load())
+        return false;
+
+    WTF::RetainPtr<CFDictionaryRef> mimeDict;
+
+    WTF::RetainPtr<CFTypeRef> mimeTypesFileName = CFBundleGetValueForInfoDictionaryKey(m_module, CFSTR("WebPluginMIMETypesFilename"));
+    if (mimeTypesFileName && CFGetTypeID(mimeTypesFileName.get()) == CFStringGetTypeID()) {
+
+        WTF::RetainPtr<CFStringRef> fileName = (CFStringRef)mimeTypesFileName.get();
+        WTF::RetainPtr<CFStringRef> homeDir = homeDirectoryPath().createCFString();
+        WTF::RetainPtr<CFStringRef> path = adoptCF(CFStringCreateWithFormat(0, 0, CFSTR("%@/Library/Preferences/%@"), homeDir.get(), fileName.get()));
+
+        WTF::RetainPtr<CFDictionaryRef> plist = readPListFile(path.get(), /*createFile*/ false, m_module);
+        if (plist) {
+            // If the plist isn't localized, have the plug-in recreate it in the preferred language.
+            WTF::RetainPtr<CFStringRef> localizationName =
+                (CFStringRef)CFDictionaryGetValue(plist.get(), CFSTR("WebPluginLocalizationName"));
+            CFLocaleRef locale = CFLocaleCopyCurrent();
+            if (localizationName != CFLocaleGetIdentifier(locale))
+                plist = readPListFile(path.get(), /*createFile*/ true, m_module);
+
+            CFRelease(locale);
+        } else {
+            // Plist doesn't exist, ask the plug-in to create it.
+            plist = readPListFile(path.get(), /*createFile*/ true, m_module);
+        }
+
+        if (plist)
+            mimeDict = (CFDictionaryRef)CFDictionaryGetValue(plist.get(), CFSTR("WebPluginMIMETypes"));
+    }
+
+    if (!mimeDict)
+        mimeDict = (CFDictionaryRef)CFBundleGetValueForInfoDictionaryKey(m_module, CFSTR("WebPluginMIMETypes"));
+
+    if (mimeDict) {
+        CFIndex propCount = CFDictionaryGetCount(mimeDict.get());
+        Vector<const void*, 128> keys(propCount);
+        Vector<const void*, 128> values(propCount);
+        CFDictionaryGetKeysAndValues(mimeDict.get(), keys.data(), values.data());
+        for (int i = 0; i < propCount; ++i) {
+            String mimeType = (CFStringRef)keys[i];
+            mimeType = mimeType.convertToASCIILowercase();
+
+            WTF::RetainPtr<CFDictionaryRef> extensionsDict = (CFDictionaryRef)values[i];
+
+            WTF::RetainPtr<CFNumberRef> enabled = (CFNumberRef)CFDictionaryGetValue(extensionsDict.get(), CFSTR("WebPluginTypeEnabled"));
+            if (enabled) {
+                int enabledValue = 0;
+                if (CFNumberGetValue(enabled.get(), kCFNumberIntType, &enabledValue) && enabledValue == 0)
+                    continue;
+            }
+
+            Vector<String> mimeExtensions;
+            WTF::RetainPtr<CFArrayRef> extensions = (CFArrayRef)CFDictionaryGetValue(extensionsDict.get(), CFSTR("WebPluginExtensions"));
+            if (extensions) {
+                CFIndex extensionCount = CFArrayGetCount(extensions.get());
+                for (CFIndex i = 0; i < extensionCount; ++i) {
+                    String extension =(CFStringRef)CFArrayGetValueAtIndex(extensions.get(), i);
+                    extension = extension.convertToASCIILowercase();
+                    mimeExtensions.append(extension);
+                }
+            }
+            m_mimeToExtensions.set(mimeType, mimeExtensions);
+
+            String description = (CFStringRef)CFDictionaryGetValue(extensionsDict.get(), CFSTR("WebPluginTypeDescription"));
+            m_mimeToDescriptions.set(mimeType, description);
+            determineQuirks(mimeType);
+        }
+
+        m_name = (CFStringRef)CFBundleGetValueForInfoDictionaryKey(m_module, CFSTR("WebPluginName"));
+        m_description = (CFStringRef)CFBundleGetValueForInfoDictionaryKey(m_module, CFSTR("WebPluginDescription"));
+
+    } else {
+        int resFile = CFBundleOpenBundleResourceMap(m_module);
+
+        UseResFile(resFile);
+
+        Vector<String> mimes = stringListFromResourceId(MIMEListStringStringNumber);
+
+        if (mimes.size() % 2 != 0)
+            return false;
+
+        Vector<String> descriptions = stringListFromResourceId(MIMEDescriptionStringNumber);
+        if (descriptions.size() != mimes.size() / 2)
+            return false;
+
+        for (size_t i = 0;  i < mimes.size(); i += 2) {
+            String mime = mimes[i].convertToASCIILowercase();
+            Vector<String> extensions;
+            mimes[i + 1].convertToASCIILowercase().split(UChar(','), extensions);
+
+            m_mimeToExtensions.set(mime, extensions);
+
+            m_mimeToDescriptions.set(mime, descriptions[i / 2]);
+        }
+
+        Vector<String> names = stringListFromResourceId(PluginNameOrDescriptionStringNumber);
+        if (names.size() == 2) {
+            m_description = names[0];
+            m_name = names[1];
+        }
+
+        CFBundleCloseBundleResourceMap(m_module, resFile);
+    }
+
+    LOG(Plugins, "PluginPackage::fetchInfo(): Found plug-in '%s'", m_name.utf8().data());
+    if (isPluginBlacklisted()) {
+        LOG(Plugins, "\tPlug-in is blacklisted!");
+        return false;
+    }
+
+    return true;
+}
+
+bool PluginPackage::isPluginBlacklisted()
+{
+    return false;
+}
+
+bool PluginPackage::load()
+{
+    if (m_isLoaded) {
+        m_loadCount++;
+        return true;
+    }
+
+    WTF::RetainPtr<CFStringRef> path = m_path.createCFString();
+    WTF::RetainPtr<CFURLRef> url = adoptCF(CFURLCreateWithFileSystemPath(kCFAllocatorDefault, path.get(),
+                                                                        kCFURLPOSIXPathStyle, false));
+    m_module = CFBundleCreate(NULL, url.get());
+    if (!m_module || !CFBundleLoadExecutable(m_module)) {
+        LOG(Plugins, "%s not loaded", m_path.utf8().data());
+        return false;
+    }
+
+    m_isLoaded = true;
+
+    NP_GetEntryPointsFuncPtr NP_GetEntryPoints = 0;
+    NP_InitializeFuncPtr NP_Initialize;
+    NPError npErr;
+
+    NP_Initialize = (NP_InitializeFuncPtr)CFBundleGetFunctionPointerForName(m_module, CFSTR("NP_Initialize"));
+    NP_GetEntryPoints = (NP_GetEntryPointsFuncPtr)CFBundleGetFunctionPointerForName(m_module, CFSTR("NP_GetEntryPoints"));
+    m_NPP_Shutdown = (NPP_ShutdownProcPtr)CFBundleGetFunctionPointerForName(m_module, CFSTR("NP_Shutdown"));
+
+    if (!NP_Initialize || !NP_GetEntryPoints || !m_NPP_Shutdown)
+        goto abort;
+
+    memset(&m_pluginFuncs, 0, sizeof(m_pluginFuncs));
+    m_pluginFuncs.size = sizeof(m_pluginFuncs);
+
+    initializeBrowserFuncs();
+
+    npErr = NP_Initialize(&m_browserFuncs);
+    LOG_NPERROR(npErr);
+    if (npErr != NPERR_NO_ERROR)
+        goto abort;
+
+    npErr = NP_GetEntryPoints(&m_pluginFuncs);
+    LOG_NPERROR(npErr);
+    if (npErr != NPERR_NO_ERROR)
+        goto abort;
+
+    m_loadCount++;
+    return true;
+
+abort:
+    unloadWithoutShutdown();
+    return false;
+}
+
+uint16_t PluginPackage::NPVersion() const
+{
+    return NP_VERSION_MINOR;
+}
+
+#if !ENABLE(PLUGIN_PACKAGE_SIMPLE_HASH)
+// functions not provided by PluginPackage.cpp in this case
+unsigned PluginPackage::hash() const
+{
+    struct HashCodes {
+        unsigned hash;
+        time_t modifiedDate;
+    } hashCodes;
+
+    hashCodes.hash = m_path.impl()->hash();
+    hashCodes.modifiedDate = m_lastModified;
+
+    return StringHasher::hashMemory<sizeof(hashCodes)>(&hashCodes);
+}
+
+bool PluginPackage::equal(const PluginPackage& a, const PluginPackage& b)
+{
+    return a.m_description == b.m_description;
+}
+#endif
+
+} // namespace WebCore
diff --git a/Source/WebKit/mac/Plugins/PluginViewMac.mm b/Source/WebKit/mac/Plugins/PluginViewMac.mm
new file mode 100644
index 0000000000000000000000000000000000000000..943996a56f9ff648441c986fa3d37042ae8cd71c
--- /dev/null
+++ b/Source/WebKit/mac/Plugins/PluginViewMac.mm
@@ -0,0 +1,671 @@
+/*
+ * Copyright (C) 2006, 2007 Apple Inc.  All rights reserved.
+ * Copyright (C) 2008 Collabora Ltd. All rights reserved.
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ * Copyright (C) 2009 Girish Ramakrishnan <girish@forwardbias.in>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "PluginView.h"
+
+#include "BridgeJSC.h"
+#include "Document.h"
+#include "DocumentLoader.h"
+#include "Element.h"
+#include "EventNames.h"
+#include "FocusController.h"
+#include "FrameLoader.h"
+#include "FrameLoadRequest.h"
+#include "FrameTree.h"
+#include "Frame.h"
+#include "FrameView.h"
+#include "GraphicsContext.h"
+#include "HostWindow.h"
+#include "HTMLNames.h"
+#include "HTMLPlugInElement.h"
+#include "Image.h"
+#include "JSDOMBinding.h"
+#include "KeyboardEvent.h"
+#include "MouseEvent.h"
+#include "NotImplemented.h"
+#include "Page.h"
+#include "PlatformMouseEvent.h"
+#include "PlatformKeyboardEvent.h"
+#include "PluginDebug.h"
+#include "PluginPackage.h"
+#include "PluginMainThreadScheduler.h"
+#include "RenderObject.h"
+#include "ScriptController.h"
+#include "Settings.h"
+#include "WheelEvent.h"
+#include "npruntime_impl.h"
+#include "runtime_root.h"
+#include <AppKit/NSEvent.h>
+#include <AppKit/NSMenu.h>
+#include <AppKit/NSWindow.h>
+#include <runtime/JSLock.h>
+#include <runtime/JSCJSValue.h>
+#include <wtf/RetainPtr.h>
+
+
+using JSC::ExecState;
+using JSC::Interpreter;
+using JSC::JSLock;
+using JSC::JSObject;
+using JSC::JSValue;
+
+#if PLATFORM(QT)
+#include <QPainter>
+#endif
+
+using namespace WTF;
+
+namespace WebCore {
+
+using namespace HTMLNames;
+
+// --------- Cocoa specific utility functions ----------
+
+static void initializeNPCocoaEvent(NPCocoaEvent* event)
+{
+    memset(event, 0, sizeof(NPCocoaEvent));
+}
+
+static int32_t getModifiers(UIEventWithKeyState *event)
+{
+    int32_t modifiers = 0;
+    if (event->keyCode() == 57) modifiers |= NSAlphaShiftKeyMask;
+    if (event->shiftKey())  modifiers |= NSShiftKeyMask;
+    if (event->ctrlKey())   modifiers |= NSControlKeyMask;
+    if (event->metaKey())   modifiers |= NSCommandKeyMask;
+    if (event->altKey())    modifiers |= NSAlternateKeyMask;
+
+    return modifiers;
+}
+
+static CGContextRef createBitmapContext(const IntSize& size)
+{
+    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();
+    uint flags = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host;
+    CGContextRef context = CGBitmapContextCreate(0, size.width(), size.height(),
+                                8, 4 * size.width(), colorspace, flags);
+
+    CGContextTranslateCTM(context, 0, size.height());
+    CGContextScaleCTM(context, 1, -1);
+    CGColorSpaceRelease(colorspace);
+    return context;
+}
+
+// --------------- Lifetime management -----------------
+
+bool PluginView::platformStart()
+{
+    ASSERT(m_isStarted);
+    ASSERT(m_status == PluginStatusLoadedSuccessfully);
+
+    // Gracefully handle unsupported drawing or event models. We can do this
+    // now since the drawing and event model can only be set during NPP_New.
+    NPBool eventModelSupported;
+    if (getValueStatic(NPNVariable(NPNVsupportsCocoaBool), &eventModelSupported) != NPERR_NO_ERROR
+            || !eventModelSupported) {
+        m_status = PluginStatusCanNotLoadPlugin;
+        LOG(Plugins, "Plug-in '%s' uses unsupported event model %s",
+                m_plugin->name().utf8().data(), prettyNameForEventModel(NPEventModelCocoa));
+        return false;
+    }
+
+    updatePluginWidget();
+
+    if (!m_plugin->quirks().contains(PluginQuirkDeferFirstSetWindowCall))
+        setNPWindowIfNeeded();
+
+    return true;
+}
+
+void PluginView::platformDestroy()
+{
+    CGContextRelease(m_contextRef);
+}
+
+// Used before the plugin view has been initialized properly, and as a
+// fallback for variables that do not require a view to resolve.
+bool PluginView::platformGetValueStatic(NPNVariable variable, void* value, NPError* result)
+{
+    switch (variable) {
+    case NPNVToolkit:
+        *static_cast<uint32_t*>(value) = 0;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    case NPNVjavascriptEnabledBool:
+        *static_cast<NPBool*>(value) = true;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    case NPNVsupportsCocoaBool:
+        *static_cast<NPBool*>(value) = true;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    // CoreGraphics is the only drawing model we support
+    case NPNVsupportsCoreGraphicsBool:
+        *static_cast<NPBool*>(value) = true;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    case NPNVsupportsAdvancedKeyHandling:
+        *static_cast<NPBool*>(value) = true;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    case NPNVsupportsOpenGLBool:
+    case NPNVsupportsCoreAnimationBool:
+        *static_cast<NPBool*>(value) = false;
+        *result = NPERR_NO_ERROR;
+        return true;
+
+    default:
+        return false;
+    }
+}
+
+// Used only for variables that need a view to resolve
+bool PluginView::platformGetValue(NPNVariable variable, void* value, NPError* error)
+{
+    // In WebKit2, this is set if the plugin queries it's availiablity and
+    // no key down events have already been sent.
+    if (variable == NPNVsupportsUpdatedCocoaTextInputBool) {
+        if (m_keyDownSent && !m_updatedCocoaTextInputRequested) {
+            *static_cast<NPBool*>(value) = false;
+            *error = NPERR_NO_ERROR;
+        }
+        else {
+            *static_cast<NPBool*>(value) = true;
+            *error = NPERR_NO_ERROR;
+            m_updatedCocoaTextInputRequested = true;
+        }
+        return true;
+    }
+    return false;
+}
+
+void PluginView::setParent(ScrollView* parent)
+{
+    LOG(Plugins, "PluginView::setParent(%p)", parent);
+
+    Widget::setParent(parent);
+
+    if (parent)
+        init();
+}
+
+// -------------- Geometry and painting ----------------
+
+void PluginView::show()
+{
+    LOG(Plugins, "PluginView::show()");
+
+    setSelfVisible(true);
+
+    Widget::show();
+}
+
+void PluginView::hide()
+{
+    LOG(Plugins, "PluginView::hide()");
+
+    setSelfVisible(false);
+
+    Widget::hide();
+}
+
+void PluginView::setFocus(bool focused)
+{
+    LOG(Plugins, "PluginView::setFocus(%d)", focused);
+    if (!focused)
+        Widget::setFocus(focused);
+
+    Widget::setFocus(focused);
+
+    if (!m_plugin || !m_isStarted || m_status != PluginStatusLoadedSuccessfully)
+        return;
+
+    NPCocoaEvent cocoaEvent;
+    initializeNPCocoaEvent(&cocoaEvent);
+    cocoaEvent.type = NPCocoaEventFocusChanged;
+    NPBool focus = focused;
+    cocoaEvent.data.focus.hasFocus = focus;
+
+    if(!dispatchNPCocoaEvent(cocoaEvent)) {
+        LOG(Events, "PluginView::setFocus(): Focus event %d not accepted", cocoaEvent.type);
+    }
+}
+
+void PluginView::setParentVisible(bool visible)
+{
+    if (isParentVisible() == visible)
+        return;
+
+    Widget::setParentVisible(visible);
+}
+
+void PluginView::setNPWindowRect(const IntRect&)
+{
+    setNPWindowIfNeeded();
+}
+
+void PluginView::setNPWindowIfNeeded()
+{
+    if (!m_isStarted || !parent() || !m_plugin->pluginFuncs()->setwindow || !m_contextRef)
+        return;
+
+    // The context is set through the draw event.
+    ASSERT(!m_npCgContext.context && !m_npCgContext.window);
+    m_npWindow.window = (void*)&m_npCgContext;
+    m_npWindow.type = NPWindowTypeDrawable;
+
+    m_npWindow.x = m_windowRect.x();
+    m_npWindow.y = m_windowRect.y();
+    m_npWindow.width = m_windowRect.width();
+    m_npWindow.height = m_windowRect.height();
+
+    m_npWindow.clipRect.left = std::max(0, m_windowRect.x());
+    m_npWindow.clipRect.top = std::max(0, m_windowRect.y());
+    m_npWindow.clipRect.right = m_windowRect.x() + m_windowRect.width();
+    m_npWindow.clipRect.bottom = m_windowRect.y() + m_windowRect.height();
+
+    LOG(Plugins, "PluginView::setNPWindowIfNeeded(): context=%p,"
+            " window.x:%d window.y:%d window.width:%d window.height:%d window.clipRect size:%dx%d",
+            m_contextRef, m_npWindow.x, m_npWindow.y, m_npWindow.width, m_npWindow.height,
+            m_npWindow.clipRect.right - m_npWindow.clipRect.left, m_npWindow.clipRect.bottom - m_npWindow.clipRect.top);
+
+    PluginView::setCurrentPluginView(this);
+    JSC::JSLock::DropAllLocks dropAllLocks(JSDOMWindowBase::commonVM());
+    setCallingPlugin(true);
+    m_plugin->pluginFuncs()->setwindow(m_instance, &m_npWindow);
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);
+}
+
+void PluginView::updatePluginWidget()
+{
+    if (!parent())
+       return;
+
+//     ASSERT(parent()->isFrameView());
+//     FrameView* frameView = toFrameView(parent());
+    ASSERT(is<FrameView>(parent()));
+    FrameView* frameView = downcast<FrameView>(parent());
+
+    IntRect oldWindowRect = m_windowRect;
+    m_windowRect = frameView->contentsToWindow(frameRect());
+
+    if (m_windowRect.size() != oldWindowRect.size()) {
+        CGContextRelease(m_contextRef);
+        m_contextRef = createBitmapContext(m_windowRect.size());
+        CGContextClearRect(m_contextRef, CGRectMake(0, 0, m_windowRect.width(), m_windowRect.height()));
+    }
+
+    if (m_windowRect != oldWindowRect)
+        setNPWindowIfNeeded();
+}
+
+void PluginView::paint(GraphicsContext& context, const IntRect& rect)
+{
+    if (!m_isStarted || m_status != PluginStatusLoadedSuccessfully) {
+        paintMissingPluginIcon(context, rect);
+        return;
+    }
+
+    if (context.paintingDisabled() || !m_contextRef)
+        return;
+
+    CGContextSaveGState(m_contextRef);
+    IntRect targetRect(frameRect());
+    targetRect.intersects(rect);
+
+    // clip the context so that plugin only updates the interested area.
+    CGRect r;
+    r.origin.x = targetRect.x() - frameRect().x();
+    r.origin.y = targetRect.y() - frameRect().y();
+    r.size.width = targetRect.width();
+    r.size.height = targetRect.height();
+    CGContextClipToRect(m_contextRef, r);
+
+    if (m_isTransparent) {
+        // Clean the pixmap in transparent mode.
+        CGContextClearRect(m_contextRef, CGRectMake(r.origin.x, r.origin.y, r.size.width, r.size.height));
+    }
+
+    NPCocoaEvent cocoaEvent;
+    initializeNPCocoaEvent(&cocoaEvent);
+    cocoaEvent.type = NPCocoaEventDrawRect;
+    cocoaEvent.data.draw.x = 0;
+    cocoaEvent.data.draw.y = 0;
+    cocoaEvent.data.draw.width = CGBitmapContextGetWidth(m_contextRef);
+    cocoaEvent.data.draw.height = CGBitmapContextGetHeight(m_contextRef);
+    cocoaEvent.data.draw.context = m_contextRef;
+
+    if(!dispatchNPCocoaEvent(cocoaEvent))
+        LOG(Events, "PluginView::paint(): Paint event type %d not accepted", cocoaEvent.type);
+    
+#if PLATFORM(QT)
+    // Paint the intermediate bitmap into our graphics context.
+    ASSERT(CGBitmapContextGetBitmapInfo(m_contextRef) & (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host));
+    ASSERT(CGBitmapContextGetBitsPerPixel(m_contextRef) == 32);
+    const uint8_t* data = reinterpret_cast<const uint8_t*>(CGBitmapContextGetData(m_contextRef));
+    size_t width = CGBitmapContextGetWidth(m_contextRef);
+    size_t height = CGBitmapContextGetHeight(m_contextRef);
+    const QImage imageFromBitmap(data, width, height, QImage::Format_ARGB32_Premultiplied);
+
+    QPainter* painter = context.platformContext();
+    painter->drawImage(targetRect.x(), targetRect.y(), imageFromBitmap,
+        targetRect.x() - frameRect().x(), targetRect.y() - frameRect().y(), targetRect.width(), targetRect.height());
+#endif
+
+    CGContextRestoreGState(m_contextRef);
+}
+
+bool PluginView::popUpContextMenu(NPMenu *menu)
+{
+    NSEvent* currentEvent = [NSApp currentEvent];
+    
+    // NPN_PopUpContextMenu must be called from within the plug-in's NPP_HandleEvent.
+    if (!currentEvent)
+        return NPERR_GENERIC_ERROR;
+    
+    NSWindow* window = [currentEvent window];
+    NSView* view = [window contentView];
+    [NSMenu popUpContextMenu:(NSMenu*)menu withEvent:currentEvent forView:view];
+    return true;
+}
+    
+void PluginView::invalidateRect(const IntRect& rect)
+{
+    invalidateWindowlessPluginRect(rect);
+}
+
+void PluginView::invalidateRect(NPRect* rect)
+{
+    IntRect r(rect->left, rect->top, rect->right - rect->left, rect->bottom - rect->top);
+    invalidateRect(r);
+}
+
+void PluginView::invalidateRegion(NPRegion region)
+{
+    // TODO: optimize
+    invalidate();
+}
+
+void PluginView::forceRedraw()
+{
+    notImplemented();
+}
+
+
+// ----------------- Event handling --------------------
+void PluginView::handleWheelEvent(WheelEvent *event)
+{
+    if (!m_isStarted)
+        return;
+    
+    NPCocoaEvent cocoaEvent;
+    initializeNPCocoaEvent(&cocoaEvent);
+    
+    NSEvent *currentEvent = [NSApp currentEvent];
+    
+    cocoaEvent.type = NPCocoaEventScrollWheel;
+    
+    cocoaEvent.data.mouse.pluginX = event->layerX() - m_npWindow.x + m_windowRect.x() - m_element->offsetLeft();
+    cocoaEvent.data.mouse.pluginY = event->layerY() - m_npWindow.y + m_windowRect.y() - m_element->offsetTop();
+    cocoaEvent.data.mouse.deltaX = [currentEvent deltaX];
+    cocoaEvent.data.mouse.deltaY = [currentEvent deltaY];
+    cocoaEvent.data.mouse.deltaZ = [currentEvent deltaZ];
+    cocoaEvent.data.mouse.modifierFlags = getModifiers(event);
+    
+    if(!dispatchNPCocoaEvent(cocoaEvent)) {
+        LOG(Events, "PluginView::handleMouseEvent(): Wheel event type %d at %d,%d not accepted", cocoaEvent.type,
+            cocoaEvent.data.mouse.pluginX, cocoaEvent.data.mouse.pluginY);
+    }
+    event->setDefaultHandled();
+}
+
+void PluginView::handleMouseEvent(MouseEvent* event)
+{
+    if (!m_isStarted)
+        return;
+    
+    NPCocoaEventType eventType;
+    int32_t buttonNumber = 0;
+    int32_t clickCount = 0;
+    NSEvent *currentEvent = [NSApp currentEvent];
+
+    NSEventType type = [currentEvent type];
+
+    switch (type) {
+        case NSLeftMouseDown:
+        case NSRightMouseDown:
+        case NSOtherMouseDown:
+            buttonNumber = [currentEvent buttonNumber];
+            clickCount = [currentEvent clickCount];
+            eventType = NPCocoaEventMouseDown;
+            // The plugin needs focus to receive keyboard events
+            if (Page* page = m_parentFrame->page())
+                page->focusController().setFocusedFrame(m_parentFrame);
+            m_parentFrame->document()->setFocusedElement(m_element);
+            break;
+
+        case NSLeftMouseUp:
+        case NSRightMouseUp:
+        case NSOtherMouseUp:
+            buttonNumber = [currentEvent buttonNumber];
+            clickCount = [currentEvent clickCount];
+            eventType = NPCocoaEventMouseUp;
+            break;
+
+        case NSMouseMoved:
+            eventType = NPCocoaEventMouseMoved;
+            break;
+
+        case NSLeftMouseDragged:
+        case NSRightMouseDragged:
+        case NSOtherMouseDragged:
+            buttonNumber = [currentEvent buttonNumber];
+            eventType = NPCocoaEventMouseDragged;
+            break;
+
+        case NSMouseEntered:
+            eventType = NPCocoaEventMouseEntered;
+            break;
+
+        case NSMouseExited:
+            eventType = NPCocoaEventMouseExited;
+        default:
+            return;
+    }
+
+    NPCocoaEvent cocoaEvent;
+    initializeNPCocoaEvent(&cocoaEvent);
+
+    cocoaEvent.type = eventType;
+    if (!(NPCocoaEventMouseEntered == eventType || NPCocoaEventMouseExited == eventType)) {
+        cocoaEvent.data.mouse.buttonNumber = buttonNumber;
+        cocoaEvent.data.mouse.clickCount = clickCount;
+    }
+
+    cocoaEvent.data.mouse.pluginX = event->layerX() - m_npWindow.x + m_windowRect.x() - m_element->offsetLeft();
+    cocoaEvent.data.mouse.pluginY = event->layerY() - m_npWindow.y + m_windowRect.y() - m_element->offsetTop();
+    cocoaEvent.data.mouse.deltaX = [currentEvent deltaX];
+    cocoaEvent.data.mouse.deltaY = [currentEvent deltaY];
+    cocoaEvent.data.mouse.deltaZ = [currentEvent deltaZ];
+    cocoaEvent.data.mouse.modifierFlags = getModifiers(event);
+
+    int16_t response = dispatchNPCocoaEvent(cocoaEvent);
+    if(response == kNPEventNotHandled) {
+        LOG(Events, "PluginView::handleMouseEvent(): Mouse event type %d at %d,%d not accepted", cocoaEvent.type,
+            cocoaEvent.data.mouse.pluginX, cocoaEvent.data.mouse.pluginY);
+    }
+
+    // Safari policy is to return true for all mouse events, because some plugins
+    // return false even if they have handled the event.
+    event->setDefaultHandled();
+}
+    
+void PluginView::handleKeyboardEvent(KeyboardEvent* event)
+{
+    if (!m_isStarted)
+        return;
+    LOG(Plugins, "PluginView::handleKeyboardEvent() ----------------- ");
+
+    LOG(Plugins, "PV::hKE(): KE.keyCode: 0x%02X, KE.charCode: %d",
+        event->keyCode(), event->charCode());
+
+    NSEvent *currentEvent = [NSApp currentEvent];
+    NPCocoaEventType eventType;
+    NSEventType type = [currentEvent type];
+
+    switch (type) {
+        case NSKeyDown:
+            eventType = NPCocoaEventKeyDown;
+            m_keyDownSent = true;
+            break;
+        case NSKeyUp:
+            if (m_disregardKeyUpCounter > 0) {
+                m_disregardKeyUpCounter--;
+                event->setDefaultHandled();
+                return;
+            }
+            eventType = NPCocoaEventKeyUp;
+            break;
+        case NSFlagsChanged:
+            eventType = NPCocoaEventFlagsChanged;
+            break;
+        default:
+            return;
+    }
+
+    NPCocoaEvent cocoaEvent;
+    initializeNPCocoaEvent(&cocoaEvent);
+    cocoaEvent.type = eventType;
+    if (eventType != NPCocoaEventFlagsChanged) {
+        NSString *characters = [currentEvent characters];
+        NSString *charactersIgnoringModifiers = [currentEvent charactersIgnoringModifiers];
+        cocoaEvent.data.key.characters = reinterpret_cast<NPNSString*>(characters);
+        cocoaEvent.data.key.charactersIgnoringModifiers = reinterpret_cast<NPNSString*>(charactersIgnoringModifiers);
+        cocoaEvent.data.key.isARepeat = [currentEvent isARepeat];
+        cocoaEvent.data.key.keyCode = [currentEvent keyCode];
+        cocoaEvent.data.key.modifierFlags = getModifiers(event);
+    }
+
+    int16_t response = dispatchNPCocoaEvent(cocoaEvent);
+    if(response == kNPEventNotHandled) {
+        LOG(Events, "PluginView::handleKeyboardEvent(): Keyboard event type %d not accepted", cocoaEvent.type);
+    } else if (response == kNPEventStartIME) {
+        // increment counter and resend as a text input
+        m_disregardKeyUpCounter++;
+        NPCocoaEvent textEvent;
+        initializeNPCocoaEvent(&textEvent);
+        textEvent.type = NPCocoaEventTextInput;
+        textEvent.data.text.text = reinterpret_cast<NPNSString*>([currentEvent characters]);
+        response = dispatchNPCocoaEvent(textEvent);
+        if(response == kNPEventNotHandled)
+            LOG(Events, "PluginView::handleKeyboardEvent(): Keyboard event type %d not accepted", cocoaEvent.type);
+    }
+
+    // All keyboard events need to be handled to prevent them falling
+    // through to the page, unless they are Meta key events, in which
+    // case they are, unless they are Cmd+a. From WebKit2, possibly
+    // not the most elegant piece of key handling code.....
+    if (event->metaKey()) {
+        if (cocoaEvent.data.key.keyCode == 0)
+            event->setDefaultHandled();
+    } else {
+        // else ignore, it's a Meta Key event for the browser.
+        event->setDefaultHandled();
+    }
+}
+
+int16_t PluginView::dispatchNPCocoaEvent(NPCocoaEvent& cocoaEvent)
+{
+    PluginView::setCurrentPluginView(this);
+    JSC::JSLock::DropAllLocks dropAllLocks(JSDOMWindowBase::commonVM());
+    setCallingPlugin(true);
+
+    int16_t response = m_plugin->pluginFuncs()->event(m_instance, &cocoaEvent);
+
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);
+
+    return response;
+}
+
+// ------------------- Miscellaneous  ------------------
+
+NPError PluginView::handlePostReadFile(Vector<char>& buffer, uint32_t len, const char* buf)
+{
+    String filename(buf, len);
+
+    if (filename.startsWith("file:///"))
+        filename = filename.substring(8);
+
+    if (!fileExists(filename))
+        return NPERR_FILE_NOT_FOUND;
+
+    FILE* fileHandle = fopen((filename.utf8()).data(), "r");
+
+    if (fileHandle == 0)
+        return NPERR_FILE_NOT_FOUND;
+
+    int bytesRead = fread(buffer.data(), 1, 0, fileHandle);
+
+    fclose(fileHandle);
+
+    if (bytesRead <= 0)
+        return NPERR_FILE_NOT_FOUND;
+
+    return NPERR_NO_ERROR;
+}
+
+// Copied from PluginViewWin.cpp
+float PluginView::deviceScaleFactor() const
+{
+    float scaleFactor = 1.0f;
+
+    if (!parent() || !parent()->isFrameView())
+        return scaleFactor;
+
+    // For windowless plugins, the device scale factor will be applied as for other page elements.
+    if (!m_isWindowed)
+        return scaleFactor;
+
+    FrameView& frameView = downcast<FrameView>(*parent());
+
+    if (frameView.frame().document())
+        scaleFactor = frameView.frame().document()->deviceScaleFactor();
+
+    return scaleFactor;
+}
+
+
+} // namespace WebCore
diff --git a/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.h b/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.h
new file mode 100644
index 0000000000000000000000000000000000000000..750fd67d0043f0808b4bc2c22c37e2b59946ff91
--- /dev/null
+++ b/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2005, 2007 Apple Computer, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer. 
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution. 
+ * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+ *     its contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <objc/objc.h>
+
+#ifdef __OBJC__
+#include <Foundation/Foundation.h>
+@class NSString;
+#else
+typedef struct objc_object NSString;
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+BOOL stringIsCaseInsensitiveEqualToString(NSString *first, NSString *second);
+BOOL hasCaseInsensitiveSuffix(NSString *, NSString *suffix);
+BOOL hasCaseInsensitivePrefix(NSString *, NSString *prefix);
+BOOL hasCaseInsensitiveSubstring(NSString *, NSString *substring);
+NSString *filenameByFixingIllegalCharacters(NSString *);
+#if !PLATFORM(IOS)
+CFStringEncoding stringEncodingForResource(Handle resource);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.mm b/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.mm
new file mode 100644
index 0000000000000000000000000000000000000000..9e0fed7fdbbe8586be09d7344d4d5582321b1588
--- /dev/null
+++ b/Source/WebKit/mac/Plugins/WebCoreNSStringExtras.mm
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2005, 2007 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer. 
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution. 
+ * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
+ *     its contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#import "config.h"
+#import "WebCoreNSStringExtras.h"
+
+#import <wtf/RetainPtr.h>
+
+BOOL stringIsCaseInsensitiveEqualToString(NSString *first, NSString *second)
+{
+    return [first compare:second options:(NSCaseInsensitiveSearch|NSLiteralSearch)] == NSOrderedSame;
+}
+
+BOOL hasCaseInsensitiveSuffix(NSString *string, NSString *suffix)
+{
+    return [string rangeOfString:suffix options:(NSCaseInsensitiveSearch | NSBackwardsSearch | NSAnchoredSearch)].location != NSNotFound;
+}
+
+BOOL hasCaseInsensitivePrefix(NSString *string, NSString *prefix)
+{
+    return [string rangeOfString:prefix options:(NSCaseInsensitiveSearch | NSAnchoredSearch)].location != NSNotFound;
+}
+
+BOOL hasCaseInsensitiveSubstring(NSString *string, NSString *substring)
+{
+    return [string rangeOfString:substring options:NSCaseInsensitiveSearch].location != NSNotFound;
+}
+
+NSString *filenameByFixingIllegalCharacters(NSString *string)
+{
+    NSMutableString *filename = [[string mutableCopy] autorelease];
+
+    // Strip null characters.
+    unichar nullChar = 0;
+    [filename replaceOccurrencesOfString:[NSString stringWithCharacters:&nullChar length:0] withString:@"" options:0 range:NSMakeRange(0, [filename length])];
+
+    // Replace "/" with "-".
+    [filename replaceOccurrencesOfString:@"/" withString:@"-" options:0 range:NSMakeRange(0, [filename length])];
+
+    // Replace ":" with "-".
+    [filename replaceOccurrencesOfString:@":" withString:@"-" options:0 range:NSMakeRange(0, [filename length])];
+    
+    // Strip leading dots.
+    while ([filename hasPrefix:@"."]) {
+        [filename deleteCharactersInRange:NSMakeRange(0,1)];
+    }
+    
+    return filename;
+}
+
+#if !PLATFORM(IOS)
+
+#if COMPILER(CLANG)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
+CFStringEncoding stringEncodingForResource(Handle resource)
+{
+    short resRef = HomeResFile(resource);
+    if (ResError() != noErr)
+        return NSMacOSRomanStringEncoding;
+    
+    // Get the FSRef for the current resource file
+    FSRef fref;
+    OSStatus error = FSGetForkCBInfo(resRef, 0, NULL, NULL, NULL, &fref, NULL);
+    if (error != noErr)
+        return NSMacOSRomanStringEncoding;
+    
+    RetainPtr<CFURLRef> url = adoptCF(CFURLCreateFromFSRef(NULL, &fref));
+    if (!url)
+        return NSMacOSRomanStringEncoding;
+
+    NSString *path = [(NSURL *)url.get() path];
+
+    // Get the lproj directory name
+    path = [path stringByDeletingLastPathComponent];
+    if (!stringIsCaseInsensitiveEqualToString([path pathExtension], @"lproj"))
+        return NSMacOSRomanStringEncoding;
+    
+    NSString *directoryName = [[path stringByDeletingPathExtension] lastPathComponent];
+    RetainPtr<CFStringRef> locale = adoptCF(CFLocaleCreateCanonicalLocaleIdentifierFromString(NULL, (CFStringRef)directoryName));
+    if (!locale)
+        return NSMacOSRomanStringEncoding;
+
+    LangCode lang;
+    RegionCode region;
+    error = LocaleStringToLangAndRegionCodes([(NSString *)locale.get() UTF8String], &lang, &region);
+    if (error != noErr)
+        return NSMacOSRomanStringEncoding;
+
+    TextEncoding encoding;
+    error = UpgradeScriptInfoToTextEncoding(kTextScriptDontCare, lang, region, NULL, &encoding);
+    if (error != noErr)
+        return NSMacOSRomanStringEncoding;
+    
+    return encoding;
+}
+
+#if COMPILER(CLANG)
+#pragma clang diagnostic pop
+#endif
+
+#endif // !PLATFORM(IOS)
diff --git a/Source/WebKit/win/Plugins/PluginDatabase.cpp b/Source/WebKit/win/Plugins/PluginDatabase.cpp
index eefcb303e5325304cab427df3d52d21cf471dfcf..aa766bc137eb832bc98fd830a9b25641d10410b5 100644
--- a/Source/WebKit/win/Plugins/PluginDatabase.cpp
+++ b/Source/WebKit/win/Plugins/PluginDatabase.cpp
@@ -25,6 +25,7 @@
  */
 
 #include "config.h"
+#include "npapi.h"
 #include "PluginDatabase.h"
 
 #include "Frame.h"
diff --git a/Source/WebKit/win/Plugins/PluginView.cpp b/Source/WebKit/win/Plugins/PluginView.cpp
index 6939439ba4032d28ede2d85e9ac6194658602db2..457dd833955566dc7e97bdc82d5de25ab9595567 100644
--- a/Source/WebKit/win/Plugins/PluginView.cpp
+++ b/Source/WebKit/win/Plugins/PluginView.cpp
@@ -179,10 +179,10 @@ void PluginView::handleEvent(Event* event)
         handleMouseEvent(static_cast<MouseEvent*>(event));
     else if (event->isKeyboardEvent())
         handleKeyboardEvent(static_cast<KeyboardEvent*>(event));
-#if defined(XP_MACOSX)
-    else if (event->type() == eventNames().wheelEvent || event->type() == eventNames().mousewheelEvent)
-        handleWheelEvent(static_cast<WheelEvent*>(event));
-#endif
+// #if defined(XP_MACOSX)
+//     else if (event->type() == eventNames().wheelEvent || event->type() == eventNames().mousewheelEvent)
+//         handleWheelEvent(static_cast<WheelEvent*>(event));
+// #endif
     else if (event->type() == eventNames().contextmenuEvent)
         event->setDefaultHandled(); // We don't know if the plug-in has handled mousedown event by displaying a context menu, so we never want WebKit to show a default one.
 #if defined(XP_UNIX) && ENABLE(NETSCAPE_PLUGIN_API)
diff --git a/Source/WebKit/win/Plugins/npapi.cpp b/Source/WebKit/win/Plugins/npapi.cpp
index 4829c694082c9c70978760671a0b95d1fc77510e..8faf055e634f7b10299dabe8e79d12241770cf9d 100644
--- a/Source/WebKit/win/Plugins/npapi.cpp
+++ b/Source/WebKit/win/Plugins/npapi.cpp
@@ -203,8 +203,8 @@ NPError NPN_GetAuthenticationInfo(NPP instance, const char* protocol, const char
 NPError NPN_PopUpContextMenu(NPP instance, NPMenu* menu)
 {
 #if PLATFORM(QT) && defined(XP_MACOSX)
-    PluginView* plugin = pluginViewForInstance(instance);
-    plugin->popUpContextMenu(menu);
+//     PluginView* plugin = pluginViewForInstance(instance);
+//     plugin->popUpContextMenu(menu);
     return NPERR_NO_ERROR;
 #else
     UNUSED_PARAM(instance);
