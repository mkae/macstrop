diff --git languages/clang/duchain/clangdiagnosticevaluator.cpp languages/clang/duchain/clangdiagnosticevaluator.cpp
index a71e711df6..0b1dc464c3 100644
--- languages/clang/duchain/clangdiagnosticevaluator.cpp
+++ languages/clang/duchain/clangdiagnosticevaluator.cpp
@@ -103,9 +103,12 @@ ClangDiagnosticEvaluator::DiagnosticType ClangDiagnosticEvaluator::diagnosticTyp
     const ClangString str(clang_getDiagnosticSpelling(diagnostic));
     const auto description = QByteArray::fromRawData(str.c_str(), qstrlen(str.c_str()));
 
+#ifndef NO_UNKNOWNDECLARATION_PROBLEM_SUPPORT
     if (isDeclarationProblem(description)) {
         return UnknownDeclarationProblem;
-    } else if (isIncludeFileNotFound(description)) {
+    } else
+#endif
+    if (isIncludeFileNotFound(description)) {
         return IncludeFileNotFoundProblem;
     } else if (isReplaceWithDotProblem(description)) {
         return ReplaceWithDotProblem;
@@ -122,9 +125,11 @@ ClangProblem* ClangDiagnosticEvaluator::createProblem(CXDiagnostic diagnostic, C
     case IncludeFileNotFoundProblem:
         return new MissingIncludePathProblem(diagnostic, unit);
         break;
+#ifndef NO_UNKNOWNDECLARATION_PROBLEM_SUPPORT
     case UnknownDeclarationProblem:
         return new class UnknownDeclarationProblem(diagnostic, unit);
         break;
+#endif
     default:
         return new ClangProblem(diagnostic, unit);
         break;
diff --git languages/clang/duchain/unknowndeclarationproblem.cpp languages/clang/duchain/unknowndeclarationproblem.cpp
index c5718cbbe1..c5bbdabcde 100644
--- languages/clang/duchain/unknowndeclarationproblem.cpp
+++ languages/clang/duchain/unknowndeclarationproblem.cpp
@@ -48,9 +48,15 @@
 #include <QDir>
 #include <QProcess>
 #include <QRegularExpression>
+#include <QCoreApplication>
+#include <QAbstractEventDispatcher>
+#include <QThread>
+#include <QEventLoop>
 
 #include <algorithm>
 
+#include <QDebug>
+
 using namespace KDevelop;
 
 namespace {
@@ -63,11 +69,190 @@ namespace {
  */
 const int maxSuggestions = 5;
 
+// #define FOREGROUND_SCANNING
+
+class UDPWorkerThread : public QThread
+{
+    Q_OBJECT
+public:
+    UDPWorkerThread(const QualifiedIdentifier& identifier, const KDevelop::Path& file,
+                    const KDevelop::DocumentRange& docrange, ClangFixits* resultPtr, QEventLoop* eventLoop)
+        : QThread(Q_NULLPTR)
+        , m_identifier(identifier)
+        , m_file(file)
+        , m_range(docrange)
+        , m_results(resultPtr)
+        , m_eventLoop(eventLoop)
+    {
+        interrupted = false;
+    }
+
+    void requestInterruption()
+    {
+        m_results = Q_NULLPTR;
+        interrupted = true;
+        if (m_eventLoop) {
+            m_eventLoop->exit(-1);
+        }
+        m_eventLoop = Q_NULLPTR;
+        qCDebug(KDEV_CLANG) << "raising interrupt request";
+        QThread::requestInterruption();
+    }
+
+    ClangFixits fixUnknownDeclaration();
+    ClangFixits scanResults()
+    {
+        if (m_results) {
+            return *m_results;
+        } else {
+            return {};
+        }
+    }
+
+    void run() override;
+
+protected:
+    bool isBlacklisted(const QString& path);
+    QStringList scanIncludePaths( const QString& identifier, const QDir& dir, int maxDepth = 3 );
+    QStringList scanIncludePaths( const QualifiedIdentifier& identifier, const KDevelop::Path::List& includes );
+    int sharedPathLevel(const QString& a, const QString& b);
+    KDevelop::DocumentRange includeDirectivePosition(const KDevelop::Path& source, const QString& includeFile);
+    KDevelop::DocumentRange forwardDeclarationPosition(const QualifiedIdentifier& identifier, const KDevelop::Path& source);
+    QVector<KDevelop::QualifiedIdentifier> findPossibleQualifiedIdentifiers( const QualifiedIdentifier& identifier, const KDevelop::Path& file, const KDevelop::CursorInRevision& cursor );
+    QStringList findMatchingIncludeFiles(const QVector<Declaration*> declarations);
+    ClangFixit directiveForFile( const QString& includefile, const KDevelop::Path::List& includepaths, const KDevelop::Path& source );
+    KDevelop::Path::List includePaths( const KDevelop::Path& file );
+    QStringList includeFiles(const QualifiedIdentifier& identifier, const QVector<Declaration*> declarations, const KDevelop::Path& file);
+    ClangFixits forwardDeclarations(const QVector<Declaration*>& matchingDeclarations, const Path& source);
+    QVector<Declaration*> findMatchingDeclarations(const QVector<QualifiedIdentifier>& identifiers);
+
+private:
+    const QualifiedIdentifier m_identifier;
+    const Path m_file;
+    const KDevelop::DocumentRange m_range;
+    ClangFixits *m_results;
+    QEventLoop *m_eventLoop;
+public:
+    static bool interrupted;
+};
+bool UDPWorkerThread::interrupted = false;
+
+class UDPScanEventLoop : public QEventLoop
+{
+    Q_OBJECT
+public:
+    UDPScanEventLoop(QObject *p=Q_NULLPTR)
+        : QEventLoop(p)
+    {
+        // empty the event queue so no events are pending anymore before we start
+        // this event loop:
+        QCoreApplication::sendPostedEvents();
+        QCoreApplication::flush();
+        QAbstractEventDispatcher *eD = QCoreApplication::eventDispatcher();
+        if (eD) {
+            eD->processEvents(QEventLoop::AllEvents);
+        } else {
+            QCoreApplication::processEvents();
+        }
+        mouseBtnPresses = 0;
+        keyReleases = 0;
+    }
+    ~UDPScanEventLoop()
+    {
+        qApp->removeEventFilter(this);
+    }
+    bool event(QEvent *e) override;
+    bool eventFilter(QObject *obj, QEvent *e) override;
+    bool causesInterrupt(QEvent *e);
+
+    int mouseBtnPresses;
+    int keyReleases;
+};
+
+bool UDPScanEventLoop::causesInterrupt(QEvent *e)
+{
+    bool ret;
+    switch (e->type()) {
+    // events that probably justify interrupting and bailing out from an ongoing scan:
+    case QEvent::ApplicationStateChange:
+    case QEvent::ContextMenu:
+    case QEvent::Drop:
+    case QEvent::FocusAboutToChange:
+    case QEvent::KeyPress:
+    case QEvent::MouseButtonDblClick:
+    case QEvent::TouchBegin:
+    case QEvent::Wheel:
+        ret = true;
+        break;
+    case QEvent::MouseButtonPress:
+        // the 1st two events are related to the user action that triggered the solutionAssistant
+        // so we do not bail out for those events.
+        mouseBtnPresses += 1;
+        ret = (mouseBtnPresses > 2);
+        break;
+    case QEvent::KeyRelease:
+        // the 1st KeyRelease event might be the Alt key, if the user triggered the solutionAssistant
+        // by pressing Alt. Just accept the 1st KeyRelease.
+        keyReleases += 1;
+        ret = (keyReleases > 1);
+        break;
+    default:
+        ret = false;
+        break;
+    }
+    return ret;
+}
+
+bool UDPScanEventLoop::event(QEvent *e)
+{
+    if (!UDPWorkerThread::interrupted && causesInterrupt(e)) {
+        UDPWorkerThread::interrupted = true;
+        qCDebug(KDEV_CLANG) << "interrupting because caught event" << e;
+    }
+
+    // hand off the event for the actual processing
+    return QEventLoop::event(e);
+}
+
+bool UDPScanEventLoop::eventFilter(QObject *obj, QEvent *e)
+{
+    if (!UDPWorkerThread::interrupted && causesInterrupt(e)) {
+        UDPWorkerThread::interrupted = true;
+        qCDebug(KDEV_CLANG) << "interrupting because caught event" << e;
+    }
+
+    // hand off the event for the actual processing
+    return QEventLoop::eventFilter(obj, e);
+}
+
+UDPWorkerThread *scanThread = Q_NULLPTR;
+
+void UDPWorkerThread::run()
+{
+    interrupted = false;
+    if (m_results) {
+        ClangFixits result = fixUnknownDeclaration();
+        if (!interrupted && m_results) {
+            *m_results = result;
+        }
+        // wipe out the public reference to ourselves;
+        if (scanThread == this) {
+            scanThread = NULL;
+        }
+    }
+    if (m_eventLoop) {
+        m_eventLoop->exit(interrupted || !m_results);
+    }
+    // m_results may point to a local variable which will go out of scope when we're done
+    m_results = Q_NULLPTR;
+    m_eventLoop = Q_NULLPTR;
+}
+
 /**
  * We don't want anything from the bits directory -
  * we'd rather prefer forwarding includes, such as <vector>
  */
-bool isBlacklisted(const QString& path)
+bool UDPWorkerThread::isBlacklisted(const QString& path)
 {
     if (ClangHelpers::isSource(path))
         return true;
@@ -80,12 +265,29 @@ bool isBlacklisted(const QString& path)
     return false;
 }
 
-QStringList scanIncludePaths( const QString& identifier, const QDir& dir, int maxDepth = 3 )
+QStringList UDPWorkerThread::scanIncludePaths( const QString& identifier, const QDir& dir, int maxDepth )
 {
     if (!maxDepth) {
         return {};
     }
 
+#ifdef FOREGROUND_SCANNING
+    QCoreApplication::sendPostedEvents();
+    QCoreApplication::flush();
+    QAbstractEventDispatcher *eD = QCoreApplication::eventDispatcher();
+    if (eD) {
+        if (eD->processEvents(QEventLoop::AllEvents)) {
+            qWarning() << Q_FUNC_INFO << "processed events, this run aborted";
+            interrupted = true;
+            return {};
+        }
+    } else {
+        QCoreApplication::processEvents();
+        qWarning() << "We may have processed events; app.eD=" << qApp->eventDispatcher()
+            << "thread.eD=" << QThread::currentThread()->eventDispatcher();
+    }
+#endif
+
     QStringList candidates;
     const auto path = dir.absolutePath();
 
@@ -100,11 +302,18 @@ QStringList scanIncludePaths( const QString& identifier, const QDir& dir, int ma
             clangDebug() << "Found candidate file" << filePath;
             candidates.append( filePath );
         }
+        if (interrupted) {
+            return {};
+        }
     }
 
     maxDepth--;
-    for( const auto& subdir : dir.entryList( QDir::Dirs | QDir::NoDotAndDotDot ) )
+    for( const auto& subdir : dir.entryList( QDir::Dirs | QDir::NoDotAndDotDot ) ) {
         candidates += scanIncludePaths( identifier, QDir{ path + QLatin1Char('/') + subdir }, maxDepth );
+        if (interrupted) {
+            return {};
+        }
+    }
 
     return candidates;
 }
@@ -112,12 +321,15 @@ QStringList scanIncludePaths( const QString& identifier, const QDir& dir, int ma
 /**
  * Find files in dir that match the given identifier. Matches common C++ header file extensions only.
  */
-QStringList scanIncludePaths( const QualifiedIdentifier& identifier, const KDevelop::Path::List& includes )
+QStringList UDPWorkerThread::scanIncludePaths( const QualifiedIdentifier& identifier, const KDevelop::Path::List& includes )
 {
     const auto stripped_identifier = identifier.last().toString();
     QStringList candidates;
     for( const auto& include : includes ) {
         candidates += scanIncludePaths( stripped_identifier, QDir{ include.toLocalFile() } );
+        if (interrupted) {
+            return {};
+        }
     }
 
     std::sort( candidates.begin(), candidates.end() );
@@ -134,7 +346,7 @@ QStringList scanIncludePaths( const QualifiedIdentifier& identifier, const KDeve
  *  boost/vector
  * have a shared path of 1
  */
-int sharedPathLevel(const QString& a, const QString& b)
+int UDPWorkerThread::sharedPathLevel(const QString& a, const QString& b)
 {
     int shared = -1;
     for(auto x = a.begin(), y = b.begin(); *x == *y && x != a.end() && y != b.end() ; ++x, ++y ) {
@@ -154,7 +366,7 @@ int sharedPathLevel(const QString& a, const QString& b)
  *
  * TODO: Implement a fallback scheme
  */
-KDevelop::DocumentRange includeDirectivePosition(const KDevelop::Path& source, const QString& includeFile)
+KDevelop::DocumentRange UDPWorkerThread::includeDirectivePosition(const KDevelop::Path& source, const QString& includeFile)
 {
     static const QRegularExpression mocFilenameExpression(QStringLiteral("(moc_[^\\/\\\\]+\\.cpp$|\\.moc$)") );
 
@@ -195,7 +407,7 @@ KDevelop::DocumentRange includeDirectivePosition(const KDevelop::Path& source, c
     return {IndexedString(source.pathOrUrl()), {line, 0, line, 0}};
 }
 
-KDevelop::DocumentRange forwardDeclarationPosition(const QualifiedIdentifier& identifier, const KDevelop::Path& source)
+KDevelop::DocumentRange UDPWorkerThread::forwardDeclarationPosition(const QualifiedIdentifier& identifier, const KDevelop::Path& source)
 {
     DUChainReadLocker lock;
     const TopDUContext* top = DUChainUtils::standardContextForUrl( source.toUrl() );
@@ -245,7 +457,7 @@ KDevelop::DocumentRange forwardDeclarationPosition(const QualifiedIdentifier& id
  * foo::type
  * type
  */
-QVector<KDevelop::QualifiedIdentifier> findPossibleQualifiedIdentifiers( const QualifiedIdentifier& identifier, const KDevelop::Path& file, const KDevelop::CursorInRevision& cursor )
+QVector<KDevelop::QualifiedIdentifier> UDPWorkerThread::findPossibleQualifiedIdentifiers( const QualifiedIdentifier& identifier, const KDevelop::Path& file, const KDevelop::CursorInRevision& cursor )
 {
     DUChainReadLocker lock;
     const TopDUContext* top = DUChainUtils::standardContextForUrl( file.toUrl() );
@@ -270,7 +482,7 @@ QVector<KDevelop::QualifiedIdentifier> findPossibleQualifiedIdentifiers( const Q
     return declarations;
 }
 
-QStringList findMatchingIncludeFiles(const QVector<Declaration*> declarations)
+QStringList UDPWorkerThread::findMatchingIncludeFiles(const QVector<Declaration*> declarations)
 {
     DUChainReadLocker lock;
 
@@ -328,7 +540,7 @@ QStringList findMatchingIncludeFiles(const QVector<Declaration*> declarations)
 /**
  * Takes a filepath and the include paths and determines what directive to use.
  */
-ClangFixit directiveForFile( const QString& includefile, const KDevelop::Path::List& includepaths, const KDevelop::Path& source )
+ClangFixit UDPWorkerThread::directiveForFile( const QString& includefile, const KDevelop::Path::List& includepaths, const KDevelop::Path& source )
 {
     const auto sourceFolder = source.parent();
     const Path canonicalFile( QFileInfo( includefile ).canonicalFilePath() );
@@ -374,7 +586,7 @@ ClangFixit directiveForFile( const QString& includefile, const KDevelop::Path::L
     return ClangFixit{directive + QLatin1Char('\n'), range, QObject::tr("Insert \'%1\'").arg(directive)};
 }
 
-KDevelop::Path::List includePaths( const KDevelop::Path& file )
+KDevelop::Path::List UDPWorkerThread::includePaths( const KDevelop::Path& file )
 {
     // Find project's custom include paths
     const auto source = file.toLocalFile();
@@ -386,7 +598,7 @@ KDevelop::Path::List includePaths( const KDevelop::Path& file )
 /**
  * Return a list of header files viable for inclusions. All elements will be unique
  */
-QStringList includeFiles(const QualifiedIdentifier& identifier, const QVector<Declaration*> declarations, const KDevelop::Path& file)
+QStringList UDPWorkerThread::includeFiles(const QualifiedIdentifier& identifier, const QVector<Declaration*> declarations, const KDevelop::Path& file)
 {
     const auto includes = includePaths( file );
     if( includes.isEmpty() ) {
@@ -406,7 +618,7 @@ QStringList includeFiles(const QualifiedIdentifier& identifier, const QVector<De
 /**
  * Construct viable forward declarations for the type name.
  */
-ClangFixits forwardDeclarations(const QVector<Declaration*>& matchingDeclarations, const Path& source)
+ClangFixits UDPWorkerThread::forwardDeclarations(const QVector<Declaration*>& matchingDeclarations, const Path& source)
 {
     DUChainReadLocker lock;
     ClangFixits fixits;
@@ -451,7 +663,7 @@ ClangFixits forwardDeclarations(const QVector<Declaration*>& matchingDeclaration
 /**
  * Search the persistent symbol table for matching declarations for identifiers @p identifiers
  */
-QVector<Declaration*> findMatchingDeclarations(const QVector<QualifiedIdentifier>& identifiers)
+QVector<Declaration*> UDPWorkerThread::findMatchingDeclarations(const QVector<QualifiedIdentifier>& identifiers)
 {
     DUChainReadLocker lock;
 
@@ -474,17 +686,17 @@ QVector<Declaration*> findMatchingDeclarations(const QVector<QualifiedIdentifier
     return matchingDeclarations;
 }
 
-ClangFixits fixUnknownDeclaration( const QualifiedIdentifier& identifier, const KDevelop::Path& file, const KDevelop::DocumentRange& docrange )
+ClangFixits UDPWorkerThread::fixUnknownDeclaration()
 {
     ClangFixits fixits;
 
-    const CursorInRevision cursor{docrange.start().line(), docrange.start().column()};
+    const CursorInRevision cursor{m_range.start().line(), m_range.start().column()};
 
-    const auto possibleIdentifiers = findPossibleQualifiedIdentifiers(identifier, file, cursor);
+    const auto possibleIdentifiers = findPossibleQualifiedIdentifiers(m_identifier, m_file, cursor);
     const auto matchingDeclarations = findMatchingDeclarations(possibleIdentifiers);
 
     if (ClangSettingsManager::self()->assistantsSettings().forwardDeclare) {
-        for (const auto& fixit : forwardDeclarations(matchingDeclarations, file)) {
+        for (const auto& fixit : forwardDeclarations(matchingDeclarations, m_file)) {
             fixits << fixit;
             if (fixits.size() == maxSuggestions) {
                 return fixits;
@@ -492,19 +704,19 @@ ClangFixits fixUnknownDeclaration( const QualifiedIdentifier& identifier, const
         }
     }
 
-    const auto includefiles = includeFiles(identifier, matchingDeclarations, file);
+    const auto includefiles = includeFiles(m_identifier, matchingDeclarations, m_file);
     if (includefiles.isEmpty()) {
         // return early as the computation of the include paths is quite expensive
         return fixits;
     }
 
-    const auto includepaths = includePaths( file );
+    const auto includepaths = includePaths( m_file );
 
     /* create fixits for candidates */
     for( const auto& includeFile : includefiles ) {
-        const auto fixit = directiveForFile( includeFile, includepaths, file /* UP */ );
+        const auto fixit = directiveForFile( includeFile, includepaths, m_file /* UP */ );
         if (!fixit.range.isValid()) {
-            clangDebug() << "unable to create directive for" << includeFile << "in" << file.toLocalFile();
+            clangDebug() << "unable to create directive for" << includeFile << "in" << m_file.toLocalFile();
             continue;
         }
 
@@ -546,6 +758,37 @@ void UnknownDeclarationProblem::setSymbol(const QualifiedIdentifier& identifier)
 IAssistant::Ptr UnknownDeclarationProblem::solutionAssistant() const
 {
     const Path path(finalLocation().document.str());
-    const auto fixits = allFixits() + fixUnknownDeclaration(m_identifier, path, finalLocation());
-    return IAssistant::Ptr(new ClangFixitAssistant(fixits));
+    if (scanThread) {
+        if (scanThread->isRunning()) {
+            scanThread->requestInterruption();
+        }
+    }
+    UDPScanEventLoop eventLoop;
+    ClangFixits unknownDeclFixits;
+    scanThread = new UDPWorkerThread(m_identifier, path, finalLocation(), &unknownDeclFixits, &eventLoop);
+    UDPWorkerThread::connect(scanThread, &UDPWorkerThread::finished, scanThread, &QObject::deleteLater);
+#ifdef FOREGROUND_SCANNING
+    unknownDeclFixits = scanThread->fixUnknownDeclaration();
+    if (!interrupted) {
+        const auto fixits = allFixits() + unknownDeclFixits;
+        return IAssistant::Ptr(new ClangFixitAssistant(fixits));
+    }
+#else
+    // eventLoop's ctor will have processed all pending events so they won't interrupt the coming scan
+    qApp->installEventFilter(&eventLoop);
+    // launch the scan of all known headerfiles for unknown declaration fixes
+    scanThread->start(QThread::IdlePriority);
+    // enter our dedicated event loop. We will exit when the worker thread calls eventLoop.exit().
+    if (eventLoop.exec(QEventLoop::AllEvents|QEventLoop::WaitForMoreEvents) == 0) {
+        return IAssistant::Ptr(new ClangFixitAssistant(allFixits() + unknownDeclFixits));
+    }
+    if (scanThread) {
+        qWarning() << Q_FUNC_INFO << "scanThread seems to have outlived its usefulness";
+        // this shouldn't happen but better safe than sorry:
+        scanThread->requestInterruption();
+    }
+#endif
+    return static_cast<IAssistant::Ptr>(NULL);
 }
+
+#include "unknowndeclarationproblem.moc"
